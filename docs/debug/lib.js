export const if_null = (value, func) => { const f = () => { func(); return null; }; return (value !== null) ? value : f(); }; export const if_not_null = (value, func) => { return (value !== null) ? func(value) : null; }; class Option { value; constructor(value) { this.value = value; } static from_undef(value) { return new Option(value); } static some(value) { return new Option(value); } static none() { return new Option(); } is_some() { return this.value !== undefined; } is_none() { return this.value === undefined; } unwrap() { return this.value; } optmatch(func) { return (this.value !== undefined) ? func.some(this.value) : func.none(); } if_all_some(opts, func) { return (opts.every(opt => opt.is_some())) ? func.all(...opts.map(opt => opt.unwrap())) : func.other(); } } export class PlayTime { h; m; s; constructor(h, m, s) { this.h = h; this.m = m; this.s = s; } toString() { return `PlayTime(${this.fmt()})`; } fmt() { return (this.h === 0) ? `${this.m}:${(this.s).toString().padStart(2, "0")}` : `${this.h}:${(this.m).toString().padStart(2, "0")}:${(this.s).toString().padStart(2, "0")}`; } distance(other) { return other.to_secs() - this.to_secs(); } to_secs() { return 3600 * this.h + 60 * this.m + this.s; } add(time) { return PlayTime.from_secs(this.to_secs() + time); } static from_secs(from) { const sec = Math.max(Math.floor(from), 0); const s = sec % 60, m = (sec - s) / 60 % 60, h = (sec - 60 * m - s) / 3600; return new PlayTime(h, m, s); } static try_from_string(from) { const time_match_result = from.match(/^(([1-9]):)?([0-5]?[0-9]):([0-5]?[0-9])$/); return if_not_null(time_match_result, (timearr) => new PlayTime(Number(timearr[2] ?? 0), Number(timearr[3]), Number(timearr[4]))); } } export class Key { code; shift; constructor(code, shift) { this.code = code; this.shift = Option.from_undef(shift); } toString() { return this.shift.optmatch({ some: (sft) => `Key(${this.code}, shift=${sft})`, none: () => `Key(${this.code})` }); } static from_KeyboardEvent(e) { return new Key(e.code, e.shiftKey); } eq(other) { if (this.code !== other.code) return false; return this.shift.if_all_some([this.shift, other.shift], { all: (thisshift, othershift) => thisshift === othershift, other: () => true }); } } export class Keymap { keymap; listen_func = undefined; constructor(...keymaps) { this.keymap = keymaps; } has(key) { return this.keymap.find(keycfg => keycfg[0].eq(key)) ?? null; } create_listener() { if (this.listen_func !== undefined) return false; this.listen_func = { keydown: (e) => { const inpkey = Key.from_KeyboardEvent(e); if_not_null(this.has(inpkey), (keycfg) => { if_not_null(keycfg[1], (func) => { console.log(`Keydown: ${inpkey}`); e.preventDefault(); func(); }); }); }, keyup: (e) => { const inpkey = Key.from_KeyboardEvent(e); if_not_null(this.has(inpkey), (keycfg) => { if_not_null(keycfg[2], (func) => { console.log(`Keyup: ${inpkey}`); e.preventDefault(); func(); }); }); } }; document.addEventListener("keydown", this.listen_func.keydown); document.addEventListener("keyup", this.listen_func.keyup); return true; } delete_listener() { if (this.listen_func === undefined) return false; document.removeEventListener("keydown", this.listen_func.keydown); document.removeEventListener("keyup", this.listen_func.keyup); this.listen_func = undefined; return true; } } export const is_running = (window) => { return typeof window.savicon_running_flag !== "undefined"; }; export const running = (window) => { window.savicon_running_flag = true; }; export const get_video_element = (index) => { return document.getElementsByTagName("video")[index] ?? null; }; export class VideoController { video; id; operate_callback = () => { }; fastplay_speed = 2.0; fastplay_flag = false; fastplay_before_speed = 0; fastplay_before_playing = true; cycle_interval_secs = 60; cycle_id = Option.none(); cookie_age_days = 1; judge_rewind = () => false; rewind_min_secs = 300; save_pause = false; before_playtime = undefined; get playing() { return !this.video.paused; } set playing(bool) { if (this.playing !== bool) this.play_toggle(); } get speed() { return this.video.playbackRate; } set speed(spd) { this.video.playbackRate = spd; this.operate_callback(); } get playtime() { return PlayTime.from_secs(this.video.currentTime); } set playtime(pt) { this.video.currentTime = pt.to_secs(); this.operate_callback(); } constructor(video, id) { this.video = video; this.id = id; } play() { if (this.video.readyState >= this.video.HAVE_FUTURE_DATA) this.video.play(); this.video.play().then(() => { }, (err) => { if (err.message !== "The play() request was interrupted by a call to pause(). https://goo.gl/LdLk22") throw err; console.log(`debug: DOMException was ignored in lib/play (https://github.com/SolAlyth/Savicon/issues/1)`); }); this.operate_callback(); } pause() { this.video.pause(); this.operate_callback(); } play_toggle() { if (this.playing) this.pause(); else this.play(); } absolute_jump(pt) { this.playtime = pt; this.operate_callback(); console.log(`jump: ${pt.fmt()}`); } relative_jump(time) { this.absolute_jump(this.playtime.add(time)); } speed_faster(interval, max) { if (this.speed <= max - interval) this.speed += interval; } speed_slower(interval, min) { if (min + interval <= this.speed) this.speed -= interval; } fastplay_on() { if (this.fastplay_flag) return false; this.fastplay_before_speed = this.speed; this.fastplay_before_playing = this.playing; this.speed = this.fastplay_speed; if (!this.playing) this.play(); this.fastplay_flag = true; return true; } fastplay_off() { if (!this.fastplay_flag) return false; this.speed = this.fastplay_before_speed; this.playing = this.fastplay_before_playing; this.fastplay_flag = false; return true; } load_cookie() { const ptl = document.cookie.split("; ").flatMap((cookie) => { const result = cookie.match(`^${this.id}=([0-9]+)$`); return (result !== null) ? [PlayTime.from_secs(Number(result[1]))] : []; }); return ptl[0] ?? null; } save_cookie() { this.before_playtime = this.playtime; document.cookie = `${this.id}=${this.playtime.to_secs()}; Max-age=${86400 * this.cookie_age_days}`; console.log(`Save: ${this.playtime.fmt()}`); } check_rewind() { const pt = this.playtime, bpt = this.before_playtime; if (pt === null || bpt === undefined) return; if (pt.to_secs() < this.cycle_interval_secs && bpt.distance(pt) < -this.rewind_min_secs) { this.save_pause = true; if (this.judge_rewind(bpt)) this.absolute_jump(bpt); this.save_pause = false; } } create_save_cycle() { if (this.cycle_id.is_some()) return false; const func = () => { if (this.save_pause) return; this.check_rewind(); this.save_cookie(); }; const interval_id = window.setInterval(func, 1000 * this.cycle_interval_secs); this.cycle_id = Option.some(interval_id); return true; } delete_save_cycle() { return this.cycle_id.optmatch({ some: (cycle_id) => { clearInterval(cycle_id); this.cycle_id = Option.none(); return true; }, none: () => false }); } }